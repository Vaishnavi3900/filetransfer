[{"path":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "name":"vector-add-buffers.cpp", "has_active_debug_locs":false, "absName":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "content":"//==============================================================\u000A// Vector Add is the equivalent of a Hello, World! sample for data parallel\u000A// programs. Building and running the sample verifies that your development\u000A// environment is setup correctly and demonstrates the use of the core features\u000A// of DPC++. This sample runs on both CPU and GPU (or FPGA). When run, it\u000A// computes on both the CPU and offload device, then compares results. If the\u000A// code executes on both CPU and offload device, the device name and a success\u000A// message are displayed. And, your development environment is setup correctly!\u000A//\u000A// For comprehensive instructions regarding DPC++ Programming, go to\u000A// https://software.intel.com/en-us/oneapi-programming-guide and search based on\u000A// relevant terms noted in the comments.\u000A//\u000A// DPC++ material used in the code sample:\u000A// •	A one dimensional array of data.\u000A// •	A device queue, buffer, accessor, and kernel.\u000A//==============================================================\u000A// Copyright © Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#include <CL/sycl.hpp>\u000A#include <vector>\u000A#include <iostream>\u000A#include <string>\u000A#if FPGA || FPGA_EMULATOR\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000Ausing namespace sycl;\u000A\u000A// Vector type and data size for this example.\u000Asize_t vector_size = 10000;\u000Atypedef std::vector<int> IntVector; \u000A\u000A// Create an exception handler for asynchronous SYCL exceptions\u000Astatic auto exception_handler = [](sycl::exception_list e_list) {\u000A  for (std::exception_ptr const &e : e_list) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    }\u000A    catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A//************************************\u000A// Vector add in DPC++ on device: returns sum in 4th parameter \"sum_parallel\".\u000A//************************************\u000Avoid VectorAdd(queue &q, const IntVector &a_vector, const IntVector &b_vector,\u000A               IntVector &sum_parallel) {\u000A  // Create the range object for the vectors managed by the buffer.\u000A  range<1> num_items{a_vector.size()};\u000A\u000A  // Create buffers that hold the data shared between the host and the devices.\u000A  // The buffer destructor is responsible to copy the data back to host when it\u000A  // goes out of scope.\u000A  buffer a_buf(a_vector);\u000A  buffer b_buf(b_vector);\u000A  buffer sum_buf(sum_parallel.data(), num_items);\u000A\u000A  // Submit a command group to the queue by a lambda function that contains the\u000A  // data access permission and device computation (kernel).\u000A  q.submit([&](handler &h) {\u000A    // Create an accessor for each buffer with access permission: read, write or\u000A    // read/write. The accessor is a mean to access the memory in the buffer.\u000A    accessor a(a_buf, h, read_only);\u000A    accessor b(b_buf, h, read_only);\u000A\u000A    // The sum_accessor is used to store (with write permission) the sum data.\u000A    accessor sum(sum_buf, h, write_only, no_init);\u000A\u000A    // Use parallel_for to run vector addition in parallel on device. This\u000A    // executes the kernel.\u000A    //    1st parameter is the number of work items.\u000A    //    2nd parameter is the kernel, a lambda that specifies what to do per\u000A    //    work item. The parameter of the lambda is the work item id.\u000A    // DPC++ supports unnamed lambda kernel by default.\u000A    h.parallel_for(num_items, [=](auto i) { sum[i] = a[i] + b[i]; });\u000A  });\u000A}\u000A\u000A//************************************\u000A// Initialize the vector from 0 to vector_size - 1\u000A//************************************\u000Avoid InitializeVector(IntVector &a) {\u000A  for (size_t i = 0; i < a.size(); i++) a.at(i) = i;\u000A}\u000A\u000A//************************************\u000A// Demonstrate vector add both in sequential on CPU and in parallel on device.\u000A//************************************\u000Aint main(int argc, char* argv[]) {\u000A  // Change vector_size if it was passed as argument\u000A  if (argc > 1) vector_size = std::stoi(argv[1]);\u000A  // Create device selector for the device of your interest.\u000A#if FPGA_EMULATOR\u000A  // DPC++ extension: FPGA emulator selector on systems without FPGA card.\u000A  ext::intel::fpga_emulator_selector d_selector;\u000A#elif FPGA\u000A  // DPC++ extension: FPGA selector on systems with FPGA card.\u000A  ext::intel::fpga_selector d_selector;\u000A#else\u000A  // The default device selector will select the most performant device.\u000A  default_selector d_selector;\u000A#endif\u000A\u000A  // Create vector objects with \"vector_size\" to store the input and output data.\u000A  IntVector a, b, sum_sequential, sum_parallel;\u000A  a.resize(vector_size);\u000A  b.resize(vector_size);\u000A  sum_sequential.resize(vector_size);\u000A  sum_parallel.resize(vector_size);\u000A\u000A  // Initialize input vectors with values from 0 to vector_size - 1\u000A  InitializeVector(a);\u000A  InitializeVector(b);\u000A\u000A  try {\u000A    queue q(d_selector, exception_handler);\u000A\u000A    // Print out the device information used for the kernel code.\u000A    std::cout << \"Running on device: \"\u000A              << q.get_device().get_info<info::device::name>() << \"\\n\";\u000A    std::cout << \"Vector size: \" << a.size() << \"\\n\";\u000A\u000A    // Vector addition in DPC++\u000A    VectorAdd(q, a, b, sum_parallel);\u000A  } catch (exception const &e) {\u000A    std::cout << \"An exception is caught for vector add.\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A  // Compute the sum of two vectors in sequential for validation.\u000A  for (size_t i = 0; i < sum_sequential.size(); i++)\u000A    sum_sequential.at(i) = a.at(i) + b.at(i);\u000A\u000A  // Verify that the two vectors are equal.  \u000A  for (size_t i = 0; i < sum_sequential.size(); i++) {\u000A    if (sum_parallel.at(i) != sum_sequential.at(i)) {\u000A      std::cout << \"Vector add failed on device.\\n\";\u000A      return -1;\u000A    }\u000A  }\u000A\u000A  int indices[]{0, 1, 2, (static_cast<int>(a.size()) - 1)};\u000A  constexpr size_t indices_size = sizeof(indices) / sizeof(int);\u000A\u000A  // Print out the result of vector add.\u000A  for (int i = 0; i < indices_size; i++) {\u000A    int j = indices[i];\u000A    if (i == indices_size - 1) std::cout << \"...\\n\";\u000A    std::cout << \"[\" << j << \"]: \" << a[j] << \" + \" << b[j] << \" = \"\u000A              << sum_parallel[j] << \"\\n\";\u000A  }\u000A\u000A  a.clear();\u000A  b.clear();\u000A  sum_sequential.clear();\u000A  sum_parallel.clear();\u000A\u000A  std::cout << \"Vector add successfully completed on device.\\n\";\u000A  return 0;\u000A}\u000A"}]