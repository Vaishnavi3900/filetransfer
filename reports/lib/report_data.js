var areaJSON={"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[43.225, 22.5298, 22.0499, 22.042, 8.10277], "total":[191675, 376789, 598, 123, 41], "name":"Kernel System", "max_resources":[854400, 1708800, 2713, 1518, 42720], "children":[{"name":"Static Partition", "type":"partition", "children":[{"name":"Board interface", "type":"resource", "data":[179950, 358572, 492, 123, 0], "details":[{"type":"text", "text":"Platform interface logic."}]}]}, {"name":"Global interconnect", "type":"resource", "data":[8779, 12545, 78, 0, 0], "details":[{"type":"text", "text":"Global interconnect for 2 global loads and 1 global store. Reduce number of global loads and stores to simplify global interconnect."}, {"type":"brief", "text":"For 2 global loads and 1 global store."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Global Memory Interconnect", "link":"file:////glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/lib/oclfpga/aoc_help_pages/hnj1476724450050.html"}]}]}, {"name":"System description ROM", "type":"resource", "data":[0, 67, 2, 0, 0], "details":[{"type":"text", "text":"This read-only memory contains information for the host about the system and about each kernel in the system, including kernel names, arguments, and attributes. The system description ROM ensures that the binary image on the FPGA is compatible with the host program."}, {"type":"brief", "text":"Contains information for the host."}]}, {"name":"\'lambda\'(auto)", "compute_units":1, "type":"function", "total_percent":[0.731943, 0.440777, 0.328008, 0.958349, 0], "total_kernel_resources":[2946, 5605, 26, 0, 41], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"\'lambda\'(auto).B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[93, 186, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[93, 186, 0, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:970 > accessor.hpp:904", "type":"resource", "data":[186, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp", "line":970}, {"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/accessor.hpp", "line":904}]], "children":[{"name":"Pointer Computation", "type":"resource", "count":3, "data":[186, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:973 > vector-add-buffers.cpp:83", "type":"resource", "data":[1143, 3008, 26, 0, 31], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp", "line":973}, {"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "line":83}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":2, "data":[720, 880, 26, 0, 0], "details":[{"type":"text", "text":"Load uses a Prefetching LSU"}, {"type":"brief", "text":"Prefetching LSU"}]}, {"name":"Store", "type":"resource", "count":1, "data":[391, 2128, 0, 0, 31], "details":[{"type":"text", "text":"Store uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:973 > vector-add-buffers.cpp:83 > \\naccessor.hpp:1552", "type":"resource", "data":[62, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp", "line":973}, {"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "line":83}, {"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/accessor.hpp", "line":1552}]], "children":[{"name":"Pointer Computation", "type":"resource", "count":1, "data":[62, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:973 > vector-add-buffers.cpp:83 > \\naccessor.hpp:1559", "type":"resource", "data":[124, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp", "line":973}, {"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "line":83}, {"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/accessor.hpp", "line":1559}]], "children":[{"name":"Pointer Computation", "type":"resource", "count":2, "data":[124, 0, 0, 0, 0]}], "replace_name":"true"}]}]}]}]};
var area_srcJSON={"children":[{"children":[{"data":[179950,358572,492,123,0],"details":[{"text":"Platform interface logic.","type":"text"}],"name":"Board interface","type":"resource"}],"name":"Static Partition","type":"partition"},{"data":[8779,12545,78,0,0],"details":[{"text":"Global interconnect for 2 global loads and 1 global store. Reduce number of global loads and stores to simplify global interconnect.","type":"text"},{"text":"For 2 global loads and 1 global store.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Global Memory Interconnect","link":"file:////glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/lib/oclfpga/aoc_help_pages/hnj1476724450050.html"}],"text":"See %L for more information","type":"text"}],"name":"Global interconnect","type":"resource"},{"data":[0,67,2,0,0],"details":[{"text":"This read-only memory contains information for the host about the system and about each kernel in the system, including kernel names, arguments, and attributes. The system description ROM ensures that the binary image on the FPGA is compatible with the host program.","type":"text"},{"text":"Contains information for the host.","type":"brief"}],"name":"System description ROM","type":"resource"},{"children":[{"data":[0,0,0,0,0],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"children":[{"count":"1","data":[93,186,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"}],"data":[93,186,0,0,0],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":3,"data":[186,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":"970"}]],"name":"Pointer Computation","type":"resource"}],"data":[186,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":970},{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/accessor.hpp","line":904}]],"name":"handler.hpp:970 > accessor.hpp:904","replace_name":true,"type":"resource"}],"data":[186,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":970}]],"name":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp:970","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":"973"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[720,880,26,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":"973"}]],"name":"Load","type":"resource"},{"count":1,"data":[391,2128,0,0,31],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":"973"}]],"name":"Store","type":"resource"}],"data":[1143,3008,26,0,31],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":973},{"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp","line":83}]],"name":"handler.hpp:973 > vector-add-buffers.cpp:83","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[62,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":"973"}]],"name":"Pointer Computation","type":"resource"}],"data":[62,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":973},{"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp","line":83},{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/accessor.hpp","line":1552}]],"name":"handler.hpp:973 > vector-add-buffers.cpp:83 > \\naccessor.hpp:1552","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[124,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":"973"}]],"name":"Pointer Computation","type":"resource"}],"data":[124,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":973},{"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp","line":83},{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/accessor.hpp","line":1559}]],"name":"handler.hpp:973 > vector-add-buffers.cpp:83 > \\naccessor.hpp:1559","replace_name":true,"type":"resource"}],"data":[1329,3008,26,0,31],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp","line":973}]],"name":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/bin-llvm/../include/sycl/CL/sycl/handler.hpp:973","replace_name":"true","type":"resource"}],"compute_units":1,"data":[2946,5605,26,0,41],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"\'lambda\'(auto)","total_kernel_resources":[2946,5605,26,0,41],"total_percent":[0.731943,0.440777,0.328008,0.958349,0],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"data":[11725,18217,106,0,41],"debug_enabled":"true","max_resources":[854400,1708800,2713,1518,42720],"name":"Kernel System","total":[191675,376789,598,123,41],"total_percent":[43.225,22.5298,22.0499,22.042,8.10277],"type":"module"};
var mavJSON={"nodes":[{"type":"kernel", "id":2, "name":"\'lambda\'(auto)", "children":[{"type":"bb", "id":3, "name":"\'lambda\'(auto).B0", "children":[{"type":"inst", "id":4, "name":"Load", "debug":[[{"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "line":83}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Prefetching", "Stall-free":"No", "Start Cycle":"1", "Latency":"2", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":5, "name":"Load", "debug":[[{"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "line":83}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Prefetching", "Stall-free":"No", "Start Cycle":"1", "Latency":"2", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":6, "name":"Store", "debug":[[{"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "line":83}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Start Cycle":"4", "Latency":"2", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":7, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":8, "name":"End", "details":[{"type":"table", "Start Cycle":"6", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"6"}]}]}, {"type":"memtype", "id":1, "name":"Global Memory", "children":[{"type":"memsys", "id":9, "name":"DDR", "details":[{"type":"table", "Number of banks":"2"}]}]}], "links":[{"from":4, "to":8}, {"from":5, "to":8}, {"from":6, "to":8}, {"from":7, "to":4}, {"from":7, "to":5}, {"from":4, "to":6}, {"from":5, "to":6}, {"from":9, "to":4}, {"from":9, "to":5}, {"from":6, "to":9}]};
var loopsJSON={"columns":["", "Pipelined", "II", "Speculated iterations", "Details"], "children":[{"name":"Kernel: \'lambda\'(auto)", "data":["", "", ""], "debug":[[{"filename":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "line":83}]], "details":[{"type":"brief", "text":"ND-Range"}, {"type":"text", "text":"ND-Range"}, {"type":"text", "text":"Fmax bottlenck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2022.1.2/oneapi/compiler/2022.0.2/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}]}]};
var loop_attrJSON={"name":"loop_attributes", "id":21, "nodes":[{"name":"\'lambda\'(auto)", "id":1, "clk":"No", "fmax":"240.00", "type":"kernel", "children":[{"name":"\'lambda\'(auto).B0", "id":2, "af":"240.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"6.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}]};
var summaryJSON={"performanceSummary":{"name":"Kernel Summary", "columns":["Kernel Name", "Kernel Type", "Autorun", "Workgroup Size", "# Compute Units"], "children":[{"name":"\'lambda\'(auto)", "data":["NDRange", "No", "n/a", 1], "details":[{"type":"text", "text":"Kernel type: NDRange"}, {"type":"text", "text":"The kernel does not use any work-group information (such as get_local_id() or get_group_id()).Local work-group size will be automatically modified to match global work-group size on launch.This is a hardware optimization."}], "debug":[[{"filename":"", "line":0}]]}]}, "estimatedResources":{"name":"Estimated Resource Usage", "columns":["Kernel Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"\'lambda\'(auto)", "data":[2946, 5605, 26, 0, 41], "debug":[[{"filename":"", "line":0}]]}, {"name":"Global Interconnect", "classes":["summary-highlight", "nohover"], "data":[8779, 12545, 78, 0, 0]}, {"name":"Board Interface", "classes":["summary-highlight", "nohover"], "data":[179950, 358572, 492, 123, 0]}, {"name":"System description ROM", "classes":["summary-highlight", "nohover"], "data":[0, 67, 2, 0, 0]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[191675, 376789, 598, 123, 41], "data_percent":[22.4339, 22.0499, 22.042, 8.10277]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[854400, 1708800, 2713, 1518, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}};
var warningsJSON={"nodes":[]};
var fileJSON=[{"path":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "name":"vector-add-buffers.cpp", "has_active_debug_locs":false, "absName":"/home/u147546/value/vector-add/src/vector-add-buffers.cpp", "content":"//==============================================================\u000A// Vector Add is the equivalent of a Hello, World! sample for data parallel\u000A// programs. Building and running the sample verifies that your development\u000A// environment is setup correctly and demonstrates the use of the core features\u000A// of DPC++. This sample runs on both CPU and GPU (or FPGA). When run, it\u000A// computes on both the CPU and offload device, then compares results. If the\u000A// code executes on both CPU and offload device, the device name and a success\u000A// message are displayed. And, your development environment is setup correctly!\u000A//\u000A// For comprehensive instructions regarding DPC++ Programming, go to\u000A// https://software.intel.com/en-us/oneapi-programming-guide and search based on\u000A// relevant terms noted in the comments.\u000A//\u000A// DPC++ material used in the code sample:\u000A// •	A one dimensional array of data.\u000A// •	A device queue, buffer, accessor, and kernel.\u000A//==============================================================\u000A// Copyright © Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#include <CL/sycl.hpp>\u000A#include <vector>\u000A#include <iostream>\u000A#include <string>\u000A#if FPGA || FPGA_EMULATOR\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000Ausing namespace sycl;\u000A\u000A// Vector type and data size for this example.\u000Asize_t vector_size = 10000;\u000Atypedef std::vector<int> IntVector; \u000A\u000A// Create an exception handler for asynchronous SYCL exceptions\u000Astatic auto exception_handler = [](sycl::exception_list e_list) {\u000A  for (std::exception_ptr const &e : e_list) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    }\u000A    catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A//************************************\u000A// Vector add in DPC++ on device: returns sum in 4th parameter \"sum_parallel\".\u000A//************************************\u000Avoid VectorAdd(queue &q, const IntVector &a_vector, const IntVector &b_vector,\u000A               IntVector &sum_parallel) {\u000A  // Create the range object for the vectors managed by the buffer.\u000A  range<1> num_items{a_vector.size()};\u000A\u000A  // Create buffers that hold the data shared between the host and the devices.\u000A  // The buffer destructor is responsible to copy the data back to host when it\u000A  // goes out of scope.\u000A  buffer a_buf(a_vector);\u000A  buffer b_buf(b_vector);\u000A  buffer sum_buf(sum_parallel.data(), num_items);\u000A\u000A  // Submit a command group to the queue by a lambda function that contains the\u000A  // data access permission and device computation (kernel).\u000A  q.submit([&](handler &h) {\u000A    // Create an accessor for each buffer with access permission: read, write or\u000A    // read/write. The accessor is a mean to access the memory in the buffer.\u000A    accessor a(a_buf, h, read_only);\u000A    accessor b(b_buf, h, read_only);\u000A\u000A    // The sum_accessor is used to store (with write permission) the sum data.\u000A    accessor sum(sum_buf, h, write_only, no_init);\u000A\u000A    // Use parallel_for to run vector addition in parallel on device. This\u000A    // executes the kernel.\u000A    //    1st parameter is the number of work items.\u000A    //    2nd parameter is the kernel, a lambda that specifies what to do per\u000A    //    work item. The parameter of the lambda is the work item id.\u000A    // DPC++ supports unnamed lambda kernel by default.\u000A    h.parallel_for(num_items, [=](auto i) { sum[i] = a[i] + b[i]; });\u000A  });\u000A}\u000A\u000A//************************************\u000A// Initialize the vector from 0 to vector_size - 1\u000A//************************************\u000Avoid InitializeVector(IntVector &a) {\u000A  for (size_t i = 0; i < a.size(); i++) a.at(i) = i;\u000A}\u000A\u000A//************************************\u000A// Demonstrate vector add both in sequential on CPU and in parallel on device.\u000A//************************************\u000Aint main(int argc, char* argv[]) {\u000A  // Change vector_size if it was passed as argument\u000A  if (argc > 1) vector_size = std::stoi(argv[1]);\u000A  // Create device selector for the device of your interest.\u000A#if FPGA_EMULATOR\u000A  // DPC++ extension: FPGA emulator selector on systems without FPGA card.\u000A  ext::intel::fpga_emulator_selector d_selector;\u000A#elif FPGA\u000A  // DPC++ extension: FPGA selector on systems with FPGA card.\u000A  ext::intel::fpga_selector d_selector;\u000A#else\u000A  // The default device selector will select the most performant device.\u000A  default_selector d_selector;\u000A#endif\u000A\u000A  // Create vector objects with \"vector_size\" to store the input and output data.\u000A  IntVector a, b, sum_sequential, sum_parallel;\u000A  a.resize(vector_size);\u000A  b.resize(vector_size);\u000A  sum_sequential.resize(vector_size);\u000A  sum_parallel.resize(vector_size);\u000A\u000A  // Initialize input vectors with values from 0 to vector_size - 1\u000A  InitializeVector(a);\u000A  InitializeVector(b);\u000A\u000A  try {\u000A    queue q(d_selector, exception_handler);\u000A\u000A    // Print out the device information used for the kernel code.\u000A    std::cout << \"Running on device: \"\u000A              << q.get_device().get_info<info::device::name>() << \"\\n\";\u000A    std::cout << \"Vector size: \" << a.size() << \"\\n\";\u000A\u000A    // Vector addition in DPC++\u000A    VectorAdd(q, a, b, sum_parallel);\u000A  } catch (exception const &e) {\u000A    std::cout << \"An exception is caught for vector add.\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A  // Compute the sum of two vectors in sequential for validation.\u000A  for (size_t i = 0; i < sum_sequential.size(); i++)\u000A    sum_sequential.at(i) = a.at(i) + b.at(i);\u000A\u000A  // Verify that the two vectors are equal.  \u000A  for (size_t i = 0; i < sum_sequential.size(); i++) {\u000A    if (sum_parallel.at(i) != sum_sequential.at(i)) {\u000A      std::cout << \"Vector add failed on device.\\n\";\u000A      return -1;\u000A    }\u000A  }\u000A\u000A  int indices[]{0, 1, 2, (static_cast<int>(a.size()) - 1)};\u000A  constexpr size_t indices_size = sizeof(indices) / sizeof(int);\u000A\u000A  // Print out the result of vector add.\u000A  for (int i = 0; i < indices_size; i++) {\u000A    int j = indices[i];\u000A    if (i == indices_size - 1) std::cout << \"...\\n\";\u000A    std::cout << \"[\" << j << \"]: \" << a[j] << \" + \" << b[j] << \" = \"\u000A              << sum_parallel[j] << \"\\n\";\u000A  }\u000A\u000A  a.clear();\u000A  b.clear();\u000A  sum_sequential.clear();\u000A  sum_parallel.clear();\u000A\u000A  std::cout << \"Vector add successfully completed on device.\\n\";\u000A  return 0;\u000A}\u000A"}];
var alpha_viewer=false;